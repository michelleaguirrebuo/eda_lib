# -*- coding: utf-8 -*-
"""Psico_lib.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19i2EmRS_LhRphtv9xxJWOlgP6rA1o9_8
"""

class Psicometrico:

    def __init__(self, file:str='', sheet:str or int=0, set_df:bool=False, df=None):
        '''
        ### Description
        Opens file
        ### Params
        - file: File name in string format.
        - sheet: 0 by default. Sheet name in case of an excel file w/
          multiple sheets
        '''
        from pandas import read_excel,read_csv
        import warnings
        warnings.filterwarnings('ignore')
        d={'xlsx':read_excel,'csv':read_csv}
        ext=file.split('.')[-1] if not set_df else None
        self.file_name=file if not set_df else None
        if set_df: self.df=df
        else:
          try:
              openf=d[ext]
              print('File format correct.')
          except KeyError:
              print('Unreadable file format. Try a csv file or an xlsx file instead.')
          try:
              if ext != 'csv':
                  self.df=openf(file,sheet_name=sheet)
                  print('File opened succesfully.')
              else:
                  with open(file) as f:
                      self.df=openf(f, encoding="utf-8")
                      print('File opened succesfully.')
          except FileNotFoundError:
              print('File path not found')
          else:
              pass
        cols=self.df.columns
        for col in cols:
            self.df.rename({col:str(col).lower().removeprefix('radarpsychometric').removesuffix('psychometric')},axis=1,inplace=True)


    def dispersion(self, columns: list or str):
        from pandas import DataFrame
        describe=self.df[columns].describe().loc[['std','max','min','25%','75%','mean','50%']]
        disp=DataFrame()
        disp['std']=describe.loc['std'].T
        disp['iqr']=describe.loc['75%'].T-describe.loc['25%'].T
        disp['range']=describe.loc['max'].T-describe.loc['min'].T
        disp['IQR/Range']=disp['iqr']/disp['range']
        disp['CV']=(disp['std']/describe.loc['mean'])*100
        disp['EDA_median']=(self.df[columns]-describe.loc['50%']).median().T
        return disp

    def normalize(self, columns: list or str, custom_scale: tuple = (None, None)):
        if custom_scale!=(None, None):
          min, max = custom_scale
          self.df[columns]=(self.df[columns]-min)/(max - min)
        else:
          self.df[columns]= (self.df[columns]-self.df[columns].min())/(self.df[columns].max()-self.df[columns].min())

    def rangosPsicometrico(self,df=None,set_df=False,nec:str='perfil', disp_metric:str= 'CV', varsFromCuadrant=5, divs=12, printRanges=False, kde=False, spiderweb=False, ):
      from seaborn import kdeplot
      from matplotlib.pyplot import figure,xlim,title
      c1=['iniciativa', 'inteligenciasocial','influencia', 'autonomia']
      c2=['desarrollo', 'orientacionservicio','diplomacia', 'disponibilidad']
      c3=['precision', 'atencionfocalizada','pensamientoanalitico', 'exctecnica']
      c4=['implementacion', 'expeditividad','determinacion', 'agentecambio']
      repna=['r', 'e','p', 'n', 'a']
      cuads=(c1,c2,c3,c4,repna)
      labels = {0:'Cuadrante 1', 1:'Cuadrante 2', 2:'Cuadrante 3', 3:'Cuadrante 4', 4:'Repna'}
      ic=[]
      everything=[]
      for cuadrant in cuads:
        if disp_metric:
          ic.append(self.dispersion(cuadrant).sort_values(disp_metric).round().head(varsFromCuadrant).index)
        else:
          ic.append(self.dispersion(cuadrant).round().index)
      for var,cuadrant in enumerate(ic):
        if printRanges:print(labels[var])
        for column in cuadrant:
          x=self.df.loc[~self.df[column].isna(),column] if not set_df else df.loc[~df[column].isna(),column]
          step=int(100/divs)
          sums=[]
          for i in range(0,100,step):
            upper_b=i+step if i+step<100 else 101
            counts=x.value_counts(normalize=True)*100
            consult=counts.loc[(counts.index<upper_b) & (counts.index>=i)]
            sums.append(((i,upper_b-1),(consult.sum())))
          sums2=[i[1].round(1) for i in sums]
          idxs=[i[0] for i in sums]
          if kde:figure(),kdeplot(x,bw_adjust=0.8),title(column),xlim(0,100)
          if printRanges:
            print(column,index:=max(sums2),idxs[sums2.index(index)])
          everything.append((column,sums))
      if spiderweb:
        self.graficarPsicometrico([col for cuadrante in cuads for col in cuadrante],nec)
      return everything


    def concentracionRangosPsico(self, rangos:list):
      from numpy import cumsum,nan,diff,round
      from pandas import DataFrame
      cols=[i[0] for i in rangos]
      rans=[list(list(zip(*i[1]))[0]) for i in rangos]
      mx=max([len(ran) for ran in rans])
      conc=[list(list(zip(*i[1]))[1]) for i in rangos]
      df=DataFrame()
      for idx,col in enumerate(cols):
        df[col+'_rangos']=rans[idx] if (ln:=len(rans[idx]))==mx else rans[idx]+[nan for _ in range(mx-ln)]
        df[col+'_concentraci贸n']=cumsum(conc[idx]) if (ln:=len(rans[idx]))==mx else cumsum(conc[idx]+[nan for _ in range(mx-ln)])
        df[col+'_diff']=diff(df[col+'_concentraci贸n'], prepend=0)
        df[col+'_concentraci贸n'],df[col+'_diff']=df[col+'_concentraci贸n'].round(2),df[col+'_diff'].round(2)
      return df

    def concentracionDiferencialGlobal(self, performanceCol:str, categories:list ,nec:str='perfil', divs=12, spiderweb=False, plots=False):
      from pandas import DataFrame,concat
      from matplotlib.pyplot import figure,xlim,title,xticks,figlegend, plot,title
      c1=['iniciativa', 'inteligenciasocial','influencia', 'autonomia']
      c2=['desarrollo', 'orientacionservicio','diplomacia', 'disponibilidad']
      c3=['precision', 'atencionfocalizada','pensamientoanalitico', 'exctecnica']
      c4=['implementacion', 'expeditividad','determinacion', 'agentecambio']
      repna=['r', 'e','p', 'n', 'a']
      cuads=(c1,c2,c3,c4,repna)
      df=self.df.loc[((self.df[performanceCol]==categories[0])|(self.df[performanceCol]==categories[1])),:]
      N=len(df)
      cat1= df.loc[(df[performanceCol]==categories[0])]
      cat2= df.loc[(df[performanceCol]==categories[1])]
      result=DataFrame()
      step=int(100/divs)
      for cuadrant in cuads:
        for variable in cuadrant:
          aux = []
          for i in range(0, 100, step):
              lb = i
              ub = i + step if i + step < 100 else 101
              ran = (lb, ub - 1)
              totCon = df.loc[(df[variable]>=lb)&(df[variable]<ub), variable].count() / N * 100
              cat1Con = cat1.loc[(cat1[variable]>=lb)&(cat1[variable]<ub), variable].count() / N * 100
              cat2Con = cat2.loc[(cat2[variable]>=lb)&(cat2[variable]<ub), variable].count() / N * 100
              diffCon = abs(cat1Con - cat2Con)
              aux.append([ran, totCon, cat1Con, cat2Con, diffCon])
          tmp = DataFrame(
              aux,
              columns=[
                  f"range_{variable}",
                  f"total_con_{variable}",
                  f"cat1_con_{variable}",
                  f"cat2_con_{variable}",
                  f"diff_con_{variable}"
              ]
          )
          result = concat([result, tmp], axis=1)
      if spiderweb:
        radar=RadarHeatmap(result.loc[:,result.columns.str.contains('diff')],columns=result.loc[:,result.columns.str.contains('diff')].columns)
        radar.plot(bw=0.1)
      if plots:
        dfx=result.loc[:,result.columns.str.contains('cat')]
        ran=result.loc[:,result.columns.str.contains('range')][result.loc[:,result.columns.str.contains('range')].columns[0]]
        ln=len(dfx.columns)
        columns=dfx.columns
        for i in range(0,ln,2):
          plt.figure()
          plt.plot(dfx[columns[i]],c='r',label=columns[i])
          plt.plot(dfx[columns[i+1]],c='b',label=columns[i+1])
          plt.xticks([i for i in range(len(ran))],ran, rotation=90)
          plt.figlegend()

      return result

    def concentracionDiferencialRelativa(self, performanceCol:str, categories:list or tuple, divs=12, spiderweb=False, plots=False):
        from pandas import DataFrame,concat
        from matplotlib.pyplot import figure,xlim,title,xticks,figlegend, plot
        rangos= [self.rangosPsicometrico(df=self.df[self.df[performanceCol]==categories[0]],divs=divs,set_df=True),
                 self.rangosPsicometrico(df=self.df[self.df[performanceCol]==categories[1]],divs=divs,set_df=True)]
        conc= [self.concentracionRangosPsico(rangos[0]),self.concentracionRangosPsico(rangos[1])]
        x= concat([conc[0].loc[:,conc[0].columns.str.contains('diff')],conc[1].loc[:,conc[1].columns.str.contains('diff')]],axis=0)
        x['cat']=[categories[0]]*len(conc[0])+[categories[1]]*len(conc[1])
        df=DataFrame()
        diffCols=[]
        cols=[i[0] for i in rangos[0]]
        for idx,col in enumerate(cols):
          df[col+'_rangos']=conc[0].loc[:,col+'_rangos']
          y= [r[0] for r in df[col+'_rangos']]
          df[col+'_diff']=conc[0].loc[:,col+'_diff']-conc[1].loc[:,col+'_diff']
          df[col+'_'+categories[0]+'_diff']=conc[0].loc[:,col+'_diff']
          df[col+'_'+categories[1]+'_diff']=conc[1].loc[:,col+'_diff']
          if plots:
            figure()
            plot(y,x.loc[x['cat']==categories[0],col+'_diff'], c='r', label=categories[0])
            plot(y,x.loc[x['cat']==categories[1],col+'_diff'], c='b', label=categories[1])
            xticks(y,conc[0].loc[:,col+'_rangos'],rotation=90)
            title(col)
            xlim(-1,100)
            figlegend()
          diffCols.append(col+'_diff')
        if spiderweb:
          radar=RadarHeatmap(df=df,columns=diffCols, ranges=(0,100))
          radar.plot(bw=0.1)
        return df

    def graficarPsicometrico(self, columns:list, nec:str='perfil'):
        radar=RadarHeatmap(self.df[~self.df[nec].isna()] , columns=columns)
        radar.plot(bw=0.1)

    def topPerfiles(self, rows:int=5, superpoder:bool=True, ignore_nans:bool=True):
        cols=['perfil'] if not superpoder else ['perfil','superpoder']
        cons=self.df[cols].value_counts(dropna=ignore_nans).reset_index(drop=False)
        cons['%']=self.df[cols].value_counts(dropna=ignore_nans,normalize=True).reset_index(drop=False)['proportion'].round(4)*100
        return cons.head(rows)

    def avg_median(self,columns: list or str,nec:str='perfil'):
        df=self.df[~self.df['perfil'].isna()][columns]
        return df.describe().T[['mean','50%']]

    def low_mid_high_proportions(self):
      from seaborn import kdeplot
      from matplotlib.pyplot import figure,xlim,title
      cols_psico=[ 'r', 'e', 'p', 'n', 'a',
       'iniciativa', 'inteligenciasocial', 'influencia', 'autonomia',
       'desarrollo', 'orientacionservicio', 'diplomacia', 'disponibilidad',
       'precision', 'atencionfocalizada', 'pensamientoanalitico', 'exctecnica',
       'implementacion', 'expeditividad', 'determinacion', 'agentecambio']
      everything=[]
      for column in cols_psico:
        x=self.df.loc[~self.df[column].isna(),column]
        step=33
        sums=[]
        for i in range(0,98,step):
              upper_b=i+step if i+step<98 else 101
              counts=x.value_counts(normalize=True)*100
              consult=counts.loc[(counts.index<upper_b) & (counts.index>=i)]
              sums.append(((i,upper_b-1),(consult.sum())))
        sums2=[i[1].round(1) for i in sums]
        idxs=[i[0] for i in sums]
        everything.append((column,sums))
      return self.concentracionRangosPsico(everything)
